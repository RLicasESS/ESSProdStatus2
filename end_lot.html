<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>END LOT</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body { margin: 0; background: #000; }
    .wrap { max-width: 1200px; margin: 0 auto; padding: 10px; }

    canvas { width: 100%; height: auto; display: block; border-radius: 14px; background: #fff; }
    img { display: none; }

    .err {
      color: #fff; background: #b00020; padding: 12px; margin: 10px;
      border-radius: 12px; font-family: Arial, sans-serif; font-weight: 900; white-space: pre-wrap;
    }

    /* QR bottom (not overlay) */
    .qrBox {
      margin: 12px auto 0 auto;
      background: rgba(255,255,255,0.92);
      border-radius: 14px;
      padding: 10px 12px;
      text-align: center;
      width: 190px;
    }
    .qrLabel {
      font-family: Arial, sans-serif;
      font-size: 12px;
      font-weight: 800;
      color: #111;
      margin-top: 6px;
      line-height: 1.2;
    }
    #qrcode { display: inline-block; }
  </style>
</head>

<body>
  <div class="wrap">
    <div id="error" class="err" style="display:none;"></div>

    <!-- hidden image source -->
    <img id="handlerImg" alt="handler" />

    <!-- final output (screenshot this) -->
    <canvas id="outCanvas"></canvas>

    <!-- QR at the bottom -->
    <div class="qrBox" id="qrWrap" style="display:none;">
      <div id="qrcode"></div>
      <div class="qrLabel">SCAN TO OPEN<br>ON PHONE</div>
    </div>
  </div>

  <!-- QR library (CDN) -->
  <script src="https://cdn.jsdelivr.net/npm/qrcodejs@1.0.0/qrcode.min.js"></script>

  <script>
    // =========================
    // CONFIG
    // =========================
    const CSV_URL = "https://raw.githubusercontent.com/RLicasESS/ESSProdStatus2/main/ESSProd.csv";

    // IMPORTANT: QR should ALWAYS point to ESSTESTER01 over HTTP
    // so phones don't hit an HTTPS page (mixed content blocks handler image)
    const ESSTESTER01_BASE = "http://10.20.10.219:8000";

    // Handler IP map (RequestServer on :8080 serves /latest.png)
    const HANDLER_IP = {
      "NS-3":   "10.20.10.187",
      "NS-4":   "10.20.10.238",
      "NS-5":   "10.20.10.98",
      "CHROMA": "10.20.10.38",
    };

    const params   = new URLSearchParams(location.search);
    const tester   = (params.get("tester") || "").trim();
    const nextStep = (params.get("next") || "").trim();
    const debug    = (params.get("debug") || "0") === "1";

    const $ = (id)=>document.getElementById(id);

    function setErr(msg){
      $("error").style.display = msg ? "" : "none";
      $("error").textContent = msg || "";
    }
    function logDebug(msg){ if (debug) console.log("[end_lot]", msg); }

    function norm(s){ return String(s ?? "").replace(/\r/g,"").trim().toUpperCase(); }
    function parseCSV(text){
      const lines = text.replace(/\r/g,"").trim().split(/\n/);
      if (!lines.length) return [];
      const delim = lines[0].includes("\t") ? "\t" : ",";
      return lines.map(l => l.split(delim));
    }
    function findRow(rows, label){
      const want = norm(label);
      return (rows || []).find(r => norm(r?.[0]) === want) || null;
    }
    function pickRow(rows, labels){
      for (const lb of labels){
        const r = findRow(rows, lb);
        if (r) return r;
      }
      return null;
    }
    function safeCell(row, c){ return row && c < row.length ? String(row[c] ?? "").trim() : ""; }
    function findColByTester(rows, tester){
      const header = rows?.[0] || [];
      const want = norm(tester);
      for (let c = 1; c < header.length; c++){
        if (norm(header[c]) === want) return c;
      }
      return -1;
    }
    function stamp(){
      const d = new Date();
      const p = n => String(n).padStart(2,"0");
      return `${d.getFullYear()}-${p(d.getMonth()+1)}-${p(d.getDate())} ${p(d.getHours())}:${p(d.getMinutes())}`;
    }

    // =========================
    // QR (always points to ESSTESTER01)
    // =========================
    function buildShareUrl(){
      const qp = new URLSearchParams();
      qp.set("tester", tester);
      if (nextStep) qp.set("next", nextStep);

      // force phone page to be HTTP on ESSTESTER01
      // (no QR on share page; no mixed-content issues)
      return `${ESSTESTER01_BASE}/end_lot_share.html?` + qp.toString();
    }

    function renderQR(){
      if (!tester) return;
      const url = buildShareUrl();

      $("qrcode").innerHTML = "";
      new QRCode($("qrcode"), {
        text: url,
        width: 160,
        height: 160,
        correctLevel: QRCode.CorrectLevel.M
      });

      $("qrWrap").style.display = "";
    }

    // =========================
    // Handler image URL
    // =========================
    function handlerLatestUrl(handlerName){
      const h = norm(handlerName).replace(/_/g,"-");
      const ip = HANDLER_IP[h];
      if (!ip) return "";
      return `http://${ip}:8080/latest.png?ts=${Date.now()}`;
    }

    async function loadImage(imgEl, url){
      imgEl.src = url;
      await new Promise((resolve, reject)=>{
        imgEl.onload = resolve;
        imgEl.onerror = reject;
      });
    }

    async function loadAndRender(){
      setErr("");
      if (!tester){
        setErr("Missing tester.\nExample:\nend_lot.html?tester=AP-1");
        return;
      }

      // QR first (this is your normal flow)
      renderQR();

      // Load CSV
      const resp = await fetch(
        CSV_URL + (CSV_URL.includes("?") ? "&" : "?") + "v=" + Date.now(),
        { cache: "no-store" }
      );
      if (!resp.ok) throw new Error(`CSV fetch failed: ${resp.status} ${resp.statusText}`);

      const rows = parseCSV(await resp.text());
      if (!rows.length) throw new Error("CSV parsed empty");

      const col = findColByTester(rows, tester);
      if (col < 0) throw new Error(`Tester '${tester}' not found in ESSProd.csv header`);

      const handlerRow = pickRow(rows, ["HANDLER"]);
      const lotRow     = pickRow(rows, ["LOT NUMBER", "LOT", "LOT_ID"]);
      const prodRow    = pickRow(rows, ["PRODUCT", "PRODUCT NAME", "PRODUCT_NAME"]);
      const stepRow    = pickRow(rows, ["TEST STEP", "STEP", "CURRENT STEP"]);
      const tempRow    = pickRow(rows, ["TEMP", "TEMPERATURE", "TEMP(C)", "TEMP (C)"]);

      const handler = safeCell(handlerRow, col).toUpperCase();
      const lot     = safeCell(lotRow, col);
      const product = safeCell(prodRow, col);
      const step    = safeCell(stepRow, col);
      const temp    = safeCell(tempRow, col);

      if (!handler) throw new Error("HANDLER cell is blank for this tester.");

      // Load handler image (desktop browsers usually allow this if page is HTTP or allowed insecure content)
      const pngUrl = handlerLatestUrl(handler);
      if (!pngUrl) throw new Error(`No HANDLER_IP mapping for handler '${handler}'`);

      const img = $("handlerImg");
      try{
        await loadImage(img, pngUrl);
      }catch{
        throw new Error(
          "Handler image failed to load.\n\n" +
          "If this page is opened as HTTPS, Chrome may block HTTP images.\n" +
          "But your QR/phone flow is fixed because it uses ESSTESTER01 HTTP.\n\n" +
          "URL:\n" + pngUrl
        );
      }

      // Labels
      const line1 = product || "(PRODUCT)";
      let line2 = lot || "(LOT)";
      if (temp && line2 && !/-(\d+(\.\d+)?)C$/i.test(line2) && /C$/i.test(temp)){
        line2 = `${line2}-${temp.replace(/\s+/g,"")}`;
      }
      const donePart = `${tester} / ${step || "STEP"} (${handler})`;
      const line3 = nextStep ? `${donePart} | Next ${nextStep}` : donePart;

      // Render combined image
      const canvas = $("outCanvas");
      const ctx = canvas.getContext("2d");

      const W = 1200;
      const pad = 40;
      const labelH = 320;
      const imgMaxH = 720;

      const scale = Math.min(W / img.naturalWidth, imgMaxH / img.naturalHeight);
      const drawW = Math.round(img.naturalWidth * scale);
      const drawH = Math.round(img.naturalHeight * scale);

      const H = pad + drawH + pad + labelH + pad;
      canvas.width = W;
      canvas.height = H;

      ctx.fillStyle = "#fff";
      ctx.fillRect(0,0,W,H);

      const x = Math.round((W - drawW)/2);
      const y = pad;
      ctx.drawImage(img, x, y, drawW, drawH);

      const boxY = y + drawH + pad;
      const boxX = pad;
      const boxW = W - pad*2;
      const boxH = labelH;

      ctx.strokeStyle = "#111";
      ctx.lineWidth = 6;
      ctx.strokeRect(boxX, boxY, boxW, boxH);

      ctx.fillStyle = "#111";
      ctx.textAlign = "center";

      ctx.font = "bold 64px Arial";
      ctx.fillText(line1, W/2, boxY + 95);

      ctx.font = "bold 58px Arial";
      ctx.fillText(line2, W/2, boxY + 170);

      ctx.font = "bold 46px Arial";
      ctx.fillText(line3, W/2, boxY + 240);

      ctx.font = "bold 26px Arial";
      ctx.textAlign = "right";
      ctx.fillText(stamp(), boxX + boxW - 10, boxY + boxH - 18);
    }

    async function refreshLoop(){
      try { await loadAndRender(); }
      catch(e){ setErr(String(e.message || e)); }
    }

    window.addEventListener("load", () => {
      refreshLoop();
      setInterval(refreshLoop, 30000);
    });
  </script>
</body>
</html>
