<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>END LOT</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body { margin: 0; background: #000; }
    .wrap { max-width: 1200px; margin: 0 auto; padding: 10px; }

    canvas { width: 100%; height: auto; display: block; border-radius: 14px; background: #fff; }
    img { display: none; }

    .err {
      color: #fff; background: #b00020; padding: 12px; margin: 10px;
      border-radius: 12px; font-family: Arial, sans-serif; font-weight: 900; white-space: pre-wrap;
    }

    /* QR bottom (not overlay) */
    .qrBox {
      margin: 12px auto 0 auto;
      background: rgba(255,255,255,0.92);
      border-radius: 14px;
      padding: 10px 12px;
      text-align: center;
      width: 190px;
    }
    .qrLabel {
      font-family: Arial, sans-serif;
      font-size: 12px;
      font-weight: 800;
      color: #111;
      margin-top: 6px;
      line-height: 1.2;
    }
    #qrcode { display: inline-block; }
  </style>
</head>

<body>
  <div class="wrap">
    <div id="error" class="err" style="display:none;"></div>

    <!-- hidden image source -->
    <img id="handlerImg" alt="handler" />

    <!-- final output (screenshot this) -->
    <canvas id="outCanvas"></canvas>

    <!-- QR at the bottom -->
    <div class="qrBox" id="qrWrap" style="display:none;">
      <div id="qrcode"></div>
      <div class="qrLabel">SCAN TO OPEN<br>ON PHONE</div>
    </div>
  </div>

  <!-- QR library (CDN) -->
  <script src="https://cdn.jsdelivr.net/npm/qrcodejs@1.0.0/qrcode.min.js"></script>

  <script>
    // ===== REPO URLs (ESSProdStatus2) =====
    const CSV_URL  = "https://raw.githubusercontent.com/RLicasESS/ESSProdStatus2/main/ESSProd.csv";
    const LOTS_URL = "https://raw.githubusercontent.com/RLicasESS/ESSProdStatus2/main/ESSlots.csv";
    // NOTE: handler images are still repo PNGs in this End Lot page:
    const PNG_BASE = "https://raw.githubusercontent.com/RLicasESS/ESSProdStatus2/main/";

    const params   = new URLSearchParams(location.search);
    const tester   = (params.get("tester") || "").trim();
    const nextStep = (params.get("next") || "").trim(); // optional passthrough

    const $ = (id)=>document.getElementById(id);

    function setErr(msg){
      $("error").style.display = msg ? "" : "none";
      $("error").textContent = msg || "";
    }
    function norm(s){ return String(s ?? "").replace(/\r/g,"").trim().toUpperCase(); }
    function parseCSV(text){
      const lines = text.replace(/\r/g,"").trim().split(/\n/);
      if (!lines.length) return [];
      const delim = lines[0].includes("\t") ? "\t" : ",";
      return lines.map(l => l.split(delim));
    }
    function findRow(rows, label){
      const want = norm(label);
      return (rows || []).find(r => norm(r?.[0]) === want) || null;
    }
    function pickRow(rows, labels){
      for (const lb of labels){
        const r = findRow(rows, lb);
        if (r) return r;
      }
      return null;
    }
    function safeCell(row, c){ return row && c < row.length ? String(row[c] ?? "").trim() : ""; }
    function findColByTester(rows, tester){
      const header = rows?.[0] || [];
      const want = norm(tester);
      for (let c = 1; c < header.length; c++){
        if (norm(header[c]) === want) return c;
      }
      return -1;
    }
    function stamp(){
      const d = new Date();
      const p = n => String(n).padStart(2,"0");
      return `${d.getFullYear()}-${p(d.getMonth()+1)}-${p(d.getDate())} ${p(d.getHours())}:${p(d.getMinutes())}`;
    }

    // ===== ESSlots helpers =====
    async function fetchCsvRows(url) {
      const resp = await fetch(
        url + (url.includes("?") ? "&" : "?") + "v=" + Date.now(),
        { cache: "no-store" }
      );
      if (!resp.ok) throw new Error(`CSV fetch failed: ${resp.status} ${resp.statusText}\n${url}`);
      const text = await resp.text();
      return parseCSV(text);
    }

    function findCol(headerRow, nameCandidates) {
      const header = headerRow || [];
      const wants = nameCandidates.map(norm);
      for (let i = 0; i < header.length; i++) {
        const h = norm(header[i]);
        if (wants.includes(h)) return i;
      }
      return -1;
    }

    function findLotRowInLots(lotsRows, lotId) {
      if (!lotsRows || lotsRows.length < 2) return null;
      const header = lotsRows[0];

      // try common column names for LOT
      let lotCol = findCol(header, ["LOT", "LOT NUMBER", "LOT_ID", "LOTID"]);
      if (lotCol < 0) lotCol = 0; // fallback first column

      const want = norm(lotId);
      for (let r = 1; r < lotsRows.length; r++) {
        if (norm(lotsRows[r]?.[lotCol]) === want) return lotsRows[r];
      }
      return null;
    }

    // ===== QR =====
    function buildShareUrl(){
      // same folder as end_lot.html on GitHub Pages
      const base = location.origin + location.pathname.replace(/[^\/]+$/, "end_lot_share.html");
      const qp = new URLSearchParams();
      qp.set("tester", tester);
      if (nextStep) qp.set("next", nextStep);
      return base + "?" + qp.toString();
    }

    function renderQR(){
      if (!tester) return;
      const url = buildShareUrl();

      $("qrcode").innerHTML = "";
      new QRCode($("qrcode"), {
        text: url,
        width: 160,
        height: 160,
        correctLevel: QRCode.CorrectLevel.M
      });

      $("qrWrap").style.display = "";
    }

    async function loadAndRender(){
      setErr("");
      if (!tester){
        setErr("Missing tester.\nExample:\nend_lot.html?tester=AP-1");
        return;
      }

      // Show QR immediately (even if data fetch fails)
      renderQR();

      // Load ESSProd + ESSlots in parallel (lots is optional)
      const [rows, lotsRows] = await Promise.all([
        fetchCsvRows(CSV_URL),
        fetchCsvRows(LOTS_URL).catch(e => {
          console.warn("ESSlots fetch failed:", e);
          return [];
        })
      ]);

      if (!rows.length) throw new Error("ESSProd.csv parsed empty");

      const col = findColByTester(rows, tester);
      if (col < 0) throw new Error(`Tester '${tester}' not found in ESSProd.csv header`);

      const handlerRow = pickRow(rows, ["HANDLER"]);
      const lotRow     = pickRow(rows, ["LOT NUMBER", "LOT", "LOT_ID"]);
      const prodRow    = pickRow(rows, ["PRODUCT", "PRODUCT NAME", "PRODUCT_NAME"]);
      const stepRow    = pickRow(rows, ["TEST STEP", "STEP", "CURRENT STEP"]);
      const tempRow    = pickRow(rows, ["TEMP", "TEMPERATURE", "TEMP(C)", "TEMP (C)"]);

      const handler = safeCell(handlerRow, col).toUpperCase();
      const lot     = safeCell(lotRow, col);
      const product = safeCell(prodRow, col);
      const step    = safeCell(stepRow, col);
      const temp    = safeCell(tempRow, col);

      if (!handler) throw new Error("HANDLER cell is blank for this tester.");

      // Optional: enrich from ESSlots.csv
      let lotExtra = "";
      if (lot && lotsRows.length) {
        const header = lotsRows[0] || [];
        const lotRow2 = findLotRowInLots(lotsRows, lot);

        if (lotRow2) {
          // choose columns if present (safe if missing)
          const qtyCol  = findCol(header, ["LOT QTY", "QTY", "IN QTY", "INPUT QTY"]);
          const devCol  = findCol(header, ["DEVICE", "DEVICE NAME", "PART", "PART NUMBER", "PART_NO"]);
          const custCol = findCol(header, ["CUSTOMER", "CUST"]);

          const parts = [];
          if (qtyCol  >= 0) parts.push(`QTY ${String(lotRow2[qtyCol] || "").trim()}`);
          if (devCol  >= 0) parts.push(String(lotRow2[devCol] || "").trim());
          if (custCol >= 0) parts.push(String(lotRow2[custCol] || "").trim());

          lotExtra = parts.filter(Boolean).join(" | ");
        }
      }

      // Load handler PNG (repo)
      const pngUrl = `${PNG_BASE}${encodeURIComponent(handler)}.png?v=${Date.now()}`;
      const img = $("handlerImg");
      img.src = pngUrl;

      await new Promise((resolve, reject)=>{
        img.onload = resolve;
        img.onerror = ()=>reject(new Error("Handler image failed to load: " + pngUrl));
      });

      // Label lines
      const line1 = product || "(PRODUCT)";

      let line2 = lot || "(LOT)";
      if (temp && line2 && !/-(\d+(\.\d+)?)C$/i.test(line2) && /C$/i.test(temp)){
        line2 = `${line2}-${temp.replace(/\s+/g,"")}`;
      }
      if (lotExtra) line2 = `${line2}  |  ${lotExtra}`;

      // DONE line includes handler now
      const donePart = `${tester} / ${step || "STEP"} | Handler ${handler}`;
      const line3 = nextStep ? `${donePart} | Next ${nextStep}` : donePart;

      // Render combined image
      const canvas = $("outCanvas");
      const ctx = canvas.getContext("2d");

      const W = 1200;
      const pad = 40;
      const labelH = 300;
      const imgMaxH = 720;

      const scale = Math.min(W / img.naturalWidth, imgMaxH / img.naturalHeight);
      const drawW = Math.round(img.naturalWidth * scale);
      const drawH = Math.round(img.naturalHeight * scale);

      const H = pad + drawH + pad + labelH + pad;
      canvas.width = W;
      canvas.height = H;

      ctx.fillStyle = "#fff";
      ctx.fillRect(0,0,W,H);

      const x = Math.round((W - drawW)/2);
      const y = pad;
      ctx.drawImage(img, x, y, drawW, drawH);

      const boxY = y + drawH + pad;
      const boxX = pad;
      const boxW = W - pad*2;
      const boxH = labelH;

      ctx.strokeStyle = "#111";
      ctx.lineWidth = 6;
      ctx.strokeRect(boxX, boxY, boxW, boxH);

      ctx.fillStyle = "#111";
      ctx.textAlign = "center";

      ctx.font = "bold 64px Arial";
      ctx.fillText(line1, W/2, boxY + 95);

      ctx.font = "bold 58px Arial";
      ctx.fillText(line2, W/2, boxY + 170);

      ctx.font = "bold 52px Arial";
      ctx.fillText(line3, W/2, boxY + 245);

      // timestamp
      ctx.font = "bold 26px Arial";
      ctx.textAlign = "right";
      ctx.fillText(stamp(), boxX + boxW - 10, boxY + boxH - 18);
    }

    async function refreshLoop(){
      try { await loadAndRender(); }
      catch(e){ setErr(String(e.message || e)); }
    }

    window.addEventListener("load", () => {
      refreshLoop();
      setInterval(refreshLoop, 30000);
    });
  </script>
</body>
</html>
