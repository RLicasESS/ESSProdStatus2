<!-- MARKER: INDEX_DEV_YIELD_V20260207_1205 -->
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>ESS PRODUCTION STATUS (DEV)</title>
  <style>
    table {
      border-collapse: collapse;
      width: 60%;
      margin: 20px auto;
      font-family: Arial, sans-serif;
    }
    th, td {
      border: 1px solid #aaa;
      padding: 8px 12px;
      text-align: left;
      vertical-align: top;
    }
    th {
      background-color: #2c3e50;
      color: white;
      font-weight: bold;
    }

    a { color: #007bff; font-weight: bold; text-decoration: none; }
    a:hover { text-decoration: underline; }

    a.statusLink,
    a.statusLink:visited,
    a.statusLink:hover,
    a.statusLink:active {
      color: inherit !important;
      font-weight: inherit !important;
      text-decoration: underline;
      cursor: pointer;
    }

    #dbg {
      width: 60%;
      margin: 6px auto 0 auto;
      font-family: Arial, sans-serif;
      font-size: 13px;
      color: #555;
      display: none;
      white-space: pre-wrap;
    }

    .lc-wrap { display: flex; flex-direction: column; gap: 6px; }
    .lc-num  { font-weight: 600; }
    .prog {
      height: 12px;
      border: 1px solid #bbb;
      border-radius: 8px;
      background: #f2f2f2;
      overflow: hidden;
    }
    .prog > .bar {
      height: 100%;
      width: 0%;
      background: #2e7d32;
    }
    .lc-pct { font-size: 12px; color: #444; }

    /* ===== Yield hover mini chart (CSS-only popup) ===== */
    .yieldHover { position: relative; display: inline-block; cursor: help; }
    .yieldHover:hover .yieldTip { display: block; }

    .yieldTip {
      display: none;
      position: absolute;
      left: 0;
      top: 110%;
      min-width: 260px;
      max-width: 300px;
      background: #fff;
      border: 1px solid #aaa;
      border-radius: 10px;
      box-shadow: 0 10px 22px rgba(0,0,0,0.18);
      padding: 10px 10px 8px 10px;
      z-index: 9999;
    }
    .yieldTipTitle {
      font-weight: 700;
      font-size: 13px;
      margin-bottom: 4px;
      color: #222;
    }
    .yieldTipSub {
      font-size: 12px;
      color: #555;
      margin-bottom: 8px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    .yieldCanvas {
      width: 240px;
      height: 80px;
      border: 1px solid #ddd;
      border-radius: 8px;
      display: block;
      background: #fafafa;
    }
    .yieldLegend {
      margin-top: 6px;
      font-size: 11px;
      color: #666;
      display: flex;
      justify-content: space-between;
    }
    .yieldNote {
      margin-top: 6px;
      font-size: 11px;
      color: #777;
    }
    .yieldRaw {
      margin-top: 8px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 10px;
      color: #444;
      background: #f7f7f7;
      border: 1px solid #e4e4e4;
      border-radius: 8px;
      padding: 6px;
      max-height: 120px;
      overflow: auto;
      display: none; /* only when ?showraw=1 */
      white-space: pre;
    }
  </style>
</head>

<body>
  <h2 id="pageTitle" style="text-align:center;">ESS PRODUCTION STATUS (DEV)</h2>
  <div id="dbg"></div>

  <script>
    const params = new URLSearchParams(window.location.search);
    const showLinks = params.get("links") === "1";
    const debug = params.get("debug") === "1";
    const showTagIfPresent = params.get("tag") === "1";

    // Yield source:
    //   ?yield=real  -> fetch yield_live.json (default)
    //   ?yield=mock  -> mock series only
    const yieldMode = (params.get("yield") || "real").toLowerCase();

    // New controls:
    //   ?clean=1 (default) -> sanitize obvious OCR/counter glitches
    //   ?smooth=none|ema|median (default none)
    //   ?alpha=0.35  (EMA alpha, used when smooth=ema)
    //   ?med=5       (median window, odd, used when smooth=median)
    //   ?yzoom=1 (default 1) -> zoom Y axis to series range with padding
    //   ?ypad=0.02   (zoom padding)
    //   ?showraw=1   -> show last few raw points in tooltip
    const cleanOn = (params.get("clean") ?? "1") === "1";
    const smoothMode = (params.get("smooth") || "none").toLowerCase();
    const emaAlpha = Number(params.get("alpha") || "0.35");
    const medWin = Math.max(3, Math.min(15, parseInt(params.get("med") || "5", 10) || 5));
    const yZoom = (params.get("yzoom") ?? "1") === "1";
    const yPad = Math.max(0, Math.min(0.2, Number(params.get("ypad") || "0.02")));
    const showRaw = params.get("showraw") === "1";

    document.title = "ESS PRODUCTION STATUS (DEV)";

    const dbgEl = document.getElementById("dbg");
    if (debug) dbgEl.style.display = "block";
    function dbg(msg) { if (debug) dbgEl.textContent = msg; }

    if (showLinks) {
      document.getElementById("pageTitle").innerHTML =
        `<a href="https://connect.raspberrypi.com/devices" target="_blank">ESS</a> PRODUCTION STATUS (DEV)`;
    }

    const CSV_URL   = "https://raw.githubusercontent.com/RLicasESS/ESSProdStatus2/main/ESSProd.csv";
    const YIELD_URL = "https://raw.githubusercontent.com/RLicasESS/ESSProdStatus2/main/yield_live.json";

    const HANDLER_IP = {
      "NS-3": "10.20.10.187",
      "NS-4": "10.20.10.238",
      "NS-5": "10.20.10.98",
      "CHROMA": "10.20.10.38",
    };

    function equalizeLastColumn(table) {
      if (!table) return;
      const headerRow = table.querySelector("tr");
      if (!headerRow) return;

      const heads = Array.from(headerRow.children);
      if (heads.length < 3) return;
      const lastIdx = heads.length - 1;

      const widths = [];
      for (let i = 1; i <= lastIdx - 1; i++) {
        const w = heads[i].getBoundingClientRect().width;
        if (w > 0) widths.push(w);
      }
      if (!widths.length) return;

      const avg = widths.reduce((a, b) => a + b, 0) / widths.length;
      for (const row of Array.from(table.rows)) {
        const cell = row.cells[lastIdx];
        if (cell) {
          cell.style.width = avg.toFixed(1) + "px";
          cell.style.maxWidth = avg.toFixed(1) + "px";
        }
      }
    }

    function showTagBox(on) {
      const el = document.getElementById("lotBox");
      if (el) el.style.display = on ? "" : "none";
    }

    function shouldShowTagBoxFromTable(rows) {
      if (!showTagIfPresent) return false;
      if (!rows) return false;

      const lotRow = (rows || []).find(r => norm(r?.[0]) === "LOT NUMBER");
      if (!lotRow) return false;

      for (let c = 1; c < lotRow.length; c++) {
        const v = String(lotRow[c] ?? "").trim();
        if (v && v.toUpperCase() !== "NA") return true;
      }
      return false;
    }

    function norm(s) { return (s || "").toString().replace(/\r/g, "").trim().toUpperCase(); }

    function toInt(x) {
      const v = parseInt((x || "").toString().replace(/,/g, "").trim(), 10);
      return Number.isNaN(v) ? null : v;
    }

    function sumAutosForCol(rows, colIndex) {
      const a1 = rows.find(r => norm(r[0]) === "AUTO1") || [];
      const a2 = rows.find(r => norm(r[0]) === "AUTO2") || [];
      const a3 = rows.find(r => norm(r[0]) === "AUTO3") || [];
      return (toInt(a1[colIndex]) || 0) + (toInt(a2[colIndex]) || 0) + (toInt(a3[colIndex]) || 0);
    }

    function parseCSV(text) {
      const lines = text.replace(/\r/g, "").trim().split(/\n/);
      if (!lines.length) return [];
      const first = lines[0];
      const delim = first.includes("\t") ? "\t" : ",";
      return lines.map(line => line.split(delim));
    }

    function parseDateTimeLocal(s) {
      const raw = (s || "").toString().trim();
      if (!raw) return null;
      let x = raw.replace(" ", "T");
      x = x.replace(/\.(\d{3})\d+/, ".$1");
      const d = new Date(x);
      return Number.isNaN(d.getTime()) ? null : d;
    }

    function pad2(n) { return String(n).padStart(2, "0"); }
    function fmtDateTime(d) {
      return `${d.getFullYear()}-${pad2(d.getMonth() + 1)}-${pad2(d.getDate())} ${pad2(d.getHours())}:${pad2(d.getMinutes())}`;
    }

    window.addEventListener("resize", () => {
      const t = document.querySelector("table");
      if (t) requestAnimationFrame(() => equalizeLastColumn(t));
    });

    function findRowByLabel(rows, label) {
      const want = norm(label);
      return (rows || []).find(r => norm(r[0]) === want) || null;
    }

    function getStepForCol(rows, colIndex) {
      const stepRow = findRowByLabel(rows, "TEST STEP");
      if (!stepRow) return "";
      return (stepRow[colIndex] || "").toString().trim();
    }

    function getLotForCol(rows, colIndex) {
      const lotRow = findRowByLabel(rows, "LOT NUMBER");
      if (!lotRow) return "";
      return (lotRow[colIndex] || "").toString().trim();
    }

    // ====== Yield hover HTML ======
    function escHtml(s) {
      return String(s ?? "")
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#39;");
    }

    function yieldHoverHtml(labelText, lot, step, which) {
      const lot2 = (lot || "").trim();
      const step2 = (step || "").trim();
      const which2 = (which || "").trim();
      return `
        <span class="yieldHover"
              data-lot="${escHtml(lot2)}"
              data-step="${escHtml(step2)}"
              data-which="${escHtml(which2)}">
          ${escHtml(labelText)}
          <div class="yieldTip">
            <div class="yieldTipTitle">${escHtml(which2)} yield history</div>
            <div class="yieldTipSub">${escHtml(lot2)} / ${escHtml(step2)}</div>
            <canvas class="yieldCanvas" width="240" height="80"></canvas>
            <div class="yieldLegend"><span>old</span><span>new</span></div>
            <div class="yieldNote" data-note>Loading…</div>
            <div class="yieldRaw" data-raw></div>
          </div>
        </span>
      `;
    }

    // ====== Yield data loader ======
    let yieldCache = null;
    let yieldCacheMode = null;

    function nowIsoNoMs() {
      const d = new Date();
      const pad = n => String(n).padStart(2,"0");
      return `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())}T${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}`;
    }

    async function fetchJson(url) {
      const res = await fetch(url + (url.includes("?") ? "&" : "?") + "v=" + Date.now(), { cache: "no-store" });
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
      const txt = await res.text();
      return JSON.parse(txt);
    }

    function makeMockYieldJsonFromRows(rows) {
      // mock shape: { data: { "LOT||STEP": { AUTO1:[...], AUTO2:[...] } } }
      const out = {
        meta: { updated: nowIsoNoMs(), mode: "mock", note: "Mock series derived from current table." },
        data: {}
      };

      const lotRow = findRowByLabel(rows, "LOT NUMBER") || [];
      const stepRow = findRowByLabel(rows, "TEST STEP") || [];
      const totalRow = findRowByLabel(rows, "TOTAL") || [];
      const auto1Row = findRowByLabel(rows, "AUTO1") || [];
      const auto2Row = findRowByLabel(rows, "AUTO2") || [];

      const maxCols = Math.max(lotRow.length, stepRow.length, totalRow.length, auto1Row.length, auto2Row.length);
      for (let c = 1; c < maxCols; c++) {
        const lot = (lotRow[c] || "").toString().trim();
        const step = (stepRow[c] || "").toString().trim();
        if (!lot || lot.toUpperCase() === "NA") continue;
        if (!step || step.toUpperCase() === "NA") continue;

        const total = toInt(totalRow[c]) || 0;
        const a1 = toInt(auto1Row[c]) || 0;
        const a2 = toInt(auto2Row[c]) || 0;

        const y1 = total > 0 ? (a1 / total) : 0;
        const y2 = total > 0 ? (a2 / total) : 0;

        const key = `${lot}||${step}`;

        function mkSeries(y) {
          const pts = [];
          let base = Math.max(0, Math.min(1, y));
          let v = Math.max(0, Math.min(1, base - 0.06));
          for (let i = 0; i < 11; i++) {
            v = v + (base - v) * 0.25 + (Math.random() - 0.5) * 0.02;
            v = Math.max(0, Math.min(1, v));
            pts.push(v);
          }
          pts.push(base);
          return pts;
        }

        out.data[key] = { lot, step, AUTO1: mkSeries(y1), AUTO2: mkSeries(y2) };
      }
      return out;
    }

    async function loadYieldCache(rowsForMock) {
      if (yieldCache && yieldCacheMode === yieldMode) return yieldCache;

      if (yieldMode === "mock") {
        yieldCache = makeMockYieldJsonFromRows(rowsForMock || []);
        yieldCacheMode = "mock";
        return yieldCache;
      }

      try {
        const j = await fetchJson(YIELD_URL);
        yieldCache = j;
        yieldCacheMode = "real";
        return yieldCache;
      } catch (e) {
        yieldCache = makeMockYieldJsonFromRows(rowsForMock || []);
        yieldCacheMode = "mock(fallback)";
        return yieldCache;
      }
    }

    function clamp01(x) { return Math.max(0, Math.min(1, x)); }

    // --- Smoothing helpers ---
    function smoothEMA(vals, alpha) {
      const a = (Number.isFinite(alpha) ? alpha : 0.35);
      if (!vals.length) return vals.slice();
      const out = [];
      let s = vals[0];
      out.push(s);
      for (let i = 1; i < vals.length; i++) {
        s = a * vals[i] + (1 - a) * s;
        out.push(s);
      }
      return out;
    }

    function median(arr) {
      const a = arr.slice().sort((x,y)=>x-y);
      const m = Math.floor(a.length/2);
      return (a.length % 2) ? a[m] : (a[m-1] + a[m]) / 2;
    }

    function smoothMedian(vals, win) {
      const w = (win % 2 === 1) ? win : (win + 1);
      const half = Math.floor(w/2);
      const out = [];
      for (let i = 0; i < vals.length; i++) {
        const lo = Math.max(0, i - half);
        const hi = Math.min(vals.length, i + half + 1);
        out.push(median(vals.slice(lo, hi)));
      }
      return out;
    }

    function applySmoothing(vals) {
      if (!vals || vals.length < 3) return vals ? vals.slice() : [];
      if (smoothMode === "ema") return smoothEMA(vals, emaAlpha);
      if (smoothMode === "median") return smoothMedian(vals, medWin);
      return vals.slice(); // none
    }

    // --- Sanitizer: repair obvious "good collapse while total steady/up" glitches ---
    function sanitizePoints(points) {
      if (!cleanOn) return points.slice();
      const cleaned = [];
      let prevGood = null;
      let prevTotal = null;

      for (const p of points) {
        const g = Number(p.good);
        const t = Number(p.total);

        if (!Number.isFinite(g) || !Number.isFinite(t) || t <= 0) {
          cleaned.push(p);
          continue;
        }

        if (prevGood != null && prevTotal != null) {
          const totalReset = (t < prevTotal * 0.70);         // treat as new run/lot boundary
          if (!totalReset) {
            const goodDroppedBig = (g < prevGood * 0.70);    // big drop
            const totalSteadyOrUp = (t >= prevTotal * 0.98);

            if (goodDroppedBig && totalSteadyOrUp) {
              const fixedGood = prevGood;
              const fixedYield = fixedGood / t;
              cleaned.push({ ...p, good: fixedGood, yield: fixedYield, y: clamp01(fixedYield), _fixed: true });
              prevTotal = t;
              continue;
            }

            if (g < prevGood && t >= prevTotal) {
              const fixedGood = prevGood;
              const fixedYield = fixedGood / t;
              cleaned.push({ ...p, good: fixedGood, yield: fixedYield, y: clamp01(fixedYield), _fixed: true });
              prevTotal = t;
              continue;
            }
          } else {
            prevGood = null;
            prevTotal = null;
          }
        }

        cleaned.push({ ...p, y: clamp01(p.y) });
        prevGood = g;
        prevTotal = t;
      }

      return cleaned;
    }

    // --- Read series from yield_live.json (REAL) or mock (MOCK) ---
    function getYieldSeries(yj, lot, step, which) {
      const lot2 = (lot || "").trim();
      const step2 = (step || "").trim();
      const which2 = (which || "").trim().toUpperCase();

      // REAL shape (your pasted data):
      // yj.data["LOT|STEP|AUTO1"] = [ {t, tester, good, total, yield}, ... ]
      const keyReal = `${lot2}|${step2}|${which2}`;

      // MOCK shape:
      // yj.data["LOT||STEP"] = { AUTO1:[...], AUTO2:[...] }
      const keyMock = `${lot2}||${step2}`;

      // Try real first
      if (yj && yj.data && Array.isArray(yj.data[keyReal]) && yj.data[keyReal].length) {
        // build points; y is yield; keep good/total/t for sanitizer + raw display
        const pts = yj.data[keyReal].map(o => {
          const y = (o && typeof o.yield === "number") ? o.yield : Number(o);
          return {
            t: (o && o.t) ? String(o.t) : "",
            tester: (o && o.tester) ? String(o.tester) : "",
            good: (o && o.good != null) ? Number(o.good) : NaN,
            total: (o && o.total != null) ? Number(o.total) : NaN,
            y: clamp01(Number.isFinite(y) ? y : 0),
            yield: Number.isFinite(y) ? y : 0
          };
        });

        // sort by time if present
        pts.sort((a,b) => String(a.t).localeCompare(String(b.t)));

        // sanitize, then convert to y array
        const cleanPts = sanitizePoints(pts);
        const yvals = cleanPts.map(p => clamp01(p.y));
        return { yvals, points: cleanPts, mode: "real" };
      }

      // Try mock
      if (yj && yj.data && yj.data[keyMock] && Array.isArray(yj.data[keyMock][which2])) {
        const arr = yj.data[keyMock][which2];
        const yvals = arr.map(x => clamp01(Number(x) || 0));
        return { yvals, points: [], mode: "mock" };
      }

      throw new Error("missing lot history");
    }

    function computeZoomRange(vals) {
      // vals are 0..1
      let mn = 1, mx = 0;
      for (const v of vals) {
        if (!Number.isFinite(v)) continue;
        mn = Math.min(mn, v);
        mx = Math.max(mx, v);
      }
      if (mn > mx) { mn = 0; mx = 1; }
      // handle flat line
      if (Math.abs(mx - mn) < 1e-6) {
        const c = mn;
        mn = Math.max(0, c - 0.05);
        mx = Math.min(1, c + 0.05);
      }
      mn = Math.max(0, mn - yPad);
      mx = Math.min(1, mx + yPad);
      // avoid super tiny range
      if (mx - mn < 0.02) {
        const mid = (mx + mn) / 2;
        mn = Math.max(0, mid - 0.01);
        mx = Math.min(1, mid + 0.01);
      }
      return { yMin: mn, yMax: mx };
    }

    function drawMiniChart(canvas, seriesVals, yMin, yMax) {
      const ctx = canvas.getContext("2d");
      const w = canvas.width, h = canvas.height;
      ctx.clearRect(0, 0, w, h);

      // background grid
      ctx.lineWidth = 1;
      ctx.strokeStyle = "#e6e6e6";
      for (let i = 1; i <= 3; i++) {
        const y = (h * i) / 4;
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(w, y);
        ctx.stroke();
      }

      // axis labels (zoomed)
      ctx.fillStyle = "#666";
      ctx.font = "11px Arial";
      const topPct = Math.round(yMax * 100);
      const botPct = Math.round(yMin * 100);
      ctx.fillText(topPct + "%", 6, 12);
      ctx.fillText(botPct + "%", 10, h - 6);

      const n = seriesVals.length;
      if (n < 2) return;

      const padL = 42, padR = 8, padT = 6, padB = 14;
      const x0 = padL, x1 = w - padR;
      const y0 = padT, y1 = h - padB;

      const denom = Math.max(1e-9, (yMax - yMin));

      ctx.strokeStyle = "#111";
      ctx.lineWidth = 2;
      ctx.beginPath();
      for (let i = 0; i < n; i++) {
        const t = i / (n - 1);
        const x = x0 + t * (x1 - x0);
        const v = seriesVals[i]; // 0..1
        const vn = (v - yMin) / denom; // normalized to zoom
        const y = y1 - clamp01(vn) * (y1 - y0);
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.stroke();

      // last point dot
      const lastV = seriesVals[n - 1];
      const lastX = x1;
      const lastVn = (lastV - yMin) / denom;
      const lastY = y1 - clamp01(lastVn) * (y1 - y0);
      ctx.fillStyle = "#111";
      ctx.beginPath();
      ctx.arc(lastX, lastY, 3, 0, Math.PI * 2);
      ctx.fill();

      // label last %
      ctx.fillStyle = "#111";
      ctx.font = "12px Arial";
      const pct = Math.round(lastV * 100);
      ctx.fillText(pct + "%", x0, h - 2);
    }

    // Delegated hover binder
    function bindYieldHoverDelegation(rowsForMock) {
      if (window.__yieldDelegationBound) return;
      window.__yieldDelegationBound = true;

      document.addEventListener("mouseover", async (ev) => {
        const el = ev.target.closest && ev.target.closest(".yieldHover");
        if (!el) return;
        if (el.dataset.loaded === "1") return;
        el.dataset.loaded = "1";

        const canvas = el.querySelector("canvas.yieldCanvas");
        const note = el.querySelector("[data-note]");
        const rawBox = el.querySelector("[data-raw]");

        if (rawBox) rawBox.style.display = showRaw ? "block" : "none";

        try {
          note.textContent = "Loading…";

          const lot = el.getAttribute("data-lot") || "";
          const step = el.getAttribute("data-step") || "";
          const which = el.getAttribute("data-which") || "";

          const yj = await loadYieldCache(rowsForMock || []);
          const got = getYieldSeries(yj, lot, step, which);

          // y-values (0..1), optionally smoothed
          const smoothed = applySmoothing(got.yvals);

          const range = yZoom ? computeZoomRange(smoothed) : { yMin: 0, yMax: 1 };
          drawMiniChart(canvas, smoothed, range.yMin, range.yMax);

          const modeShown = (yieldCacheMode || yieldMode);
          const cleanTag = cleanOn ? "clean" : "raw";
          const smoothTag = smoothMode === "none" ? "no-smooth" : (smoothMode === "ema" ? `ema(a=${emaAlpha})` : `median(w=${medWin})`);
          const zoomTag = yZoom ? `zoom(${Math.round(range.yMin*100)}–${Math.round(range.yMax*100)}%)` : "full(0–100%)";

          note.textContent = (modeShown.startsWith("mock") ? "Mock data" : "Real data") + ` • ${cleanTag} • ${smoothTag} • ${zoomTag}`;

          if (showRaw && rawBox) {
            if (got.points && got.points.length) {
              const last = got.points.slice(-8);
              const lines = last.map(p => {
                const t = (p.t || "").replace("T", " ").slice(0,16);
                const y = (p.yield != null) ? (p.yield * 100).toFixed(2) + "%" : "NA";
                const g = Number.isFinite(p.good) ? String(Math.trunc(p.good)) : "NA";
                const tot = Number.isFinite(p.total) ? String(Math.trunc(p.total)) : "NA";
                const fx = p._fixed ? " FIX" : "";
                return `${t}  y=${y}  good=${g}  total=${tot}${fx}`;
              });
              rawBox.textContent = lines.join("\n");
            } else {
              rawBox.textContent = "(no raw points in this mode)";
            }
          }

        } catch (e) {
          const ctx = canvas.getContext("2d");
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          ctx.fillStyle = "#b00020";
          ctx.font = "12px Arial";
          ctx.fillText("missing lot history", 10, 22);
          note.textContent = "Missing lot history";
          if (rawBox) rawBox.textContent = "";
        }
      });
    }

    // ===== existing freeze logic state =====
    let prevRowsByLabel = null;
    let lastCSVRows = null;

    async function loadCSV() {
      try {
        dbg(
`Loading CSV…
Yield mode: ${yieldMode}
Yield URL: ${YIELD_URL}
clean=${cleanOn} smooth=${smoothMode} alpha=${emaAlpha} med=${medWin}
yzoom=${yZoom} ypad=${yPad} showraw=${showRaw}`
        );

        const resp = await fetch(
          CSV_URL + (CSV_URL.includes("?") ? "&" : "?") + "v=" + Date.now(),
          { cache: "no-store" }
        );

        if (!resp.ok) { dbg(`CSV fetch failed: ${resp.status} ${resp.statusText}`); return; }

        const text = await resp.text();
        const rows = parseCSV(text);
        if (!rows.length) { dbg("CSV parsed but rows is empty."); return; }

        showTagBox(shouldShowTagBoxFromTable(rows));

        const handlerRow = rows.find(r => norm(r[0]) === "HANDLER") || [];
        function handlerAtCol(colIndex) {
          return (handlerRow[colIndex] || "").toString().trim().toUpperCase();
        }

        const statusRow = rows.find(r => norm(r[0]) === "STATUS") || [];
        const statusByCol = {};
        for (let c = 1; c < statusRow.length; c++) statusByCol[c] = (statusRow[c] || "").toString().trim().toLowerCase();

        const totalInRow = rows.find(r => norm(r[0]) === "TOTAL IN") || [];
        const totalInByCol = {};
        for (let c = 1; c < totalInRow.length; c++) {
          const v = toInt(totalInRow[c]);
          if (v !== null) totalInByCol[c] = v;
        }

        const totalRow = rows.find(r => norm(r[0]) === "TOTAL") || [];

        // Freeze numeric values when STATUS=error for that column
        const freezeLabels = new Set(["TOTAL IN", "LOADING COUNTS", "TOTAL", "AUTO1", "AUTO2", "AUTO3"]);
        if (prevRowsByLabel) {
          for (const r of rows) {
            const label = norm(r[0]);
            if (!freezeLabels.has(label)) continue;
            const prevRow = prevRowsByLabel[label];
            if (!prevRow) continue;

            for (let c = 1; c < r.length; c++) {
              if ((statusByCol[c] || "") === "error") {
                const prevVal = prevRow[c];
                if (prevVal !== undefined && String(prevVal).trim() !== "") r[c] = prevVal;
              }
            }
          }
        }

        lastCSVRows = rows;

        function findLastRow(rows, label) {
          const want = norm(label);
          for (let i = rows.length - 1; i >= 0; i--) {
            if (norm(rows[i]?.[0]) === want) return rows[i];
          }
          return null;
        }

        const startRow   = rows.find(r => norm(r[0]) === "DATE LOT STARTED") || [];
        const lastUpdRow = findLastRow(rows, "LAST UPDATE") || [];
        const loadingRow = rows.find(r => norm(r[0]) === "LOADING COUNTS") || [];

        // Estimated finish row
        const estFinishRow = [];
        estFinishRow[0] = "ESTIMATED FINISH";
        const maxColsEF = Math.max(...rows.map(r => r.length));
        for (let c = 1; c < maxColsEF; c++) {
          const startDt = parseDateTimeLocal(startRow[c]);
          const updDt   = parseDateTimeLocal(lastUpdRow[c]);
          const loading = toInt(loadingRow[c]);
          const totalIn = totalInByCol[c];

          if (!startDt || !updDt || loading === null || !totalIn || totalIn <= 0) { estFinishRow[c] = ""; continue; }

          const elapsedMs = updDt.getTime() - startDt.getTime();
          const progress = loading / totalIn;
          if (elapsedMs <= 0 || progress <= 0) { estFinishRow[c] = ""; continue; }

          const p = Math.min(1, Math.max(0.000001, progress));
          const estTotalMs = elapsedMs / p;
          const finishDt = new Date(startDt.getTime() + estTotalMs);
          estFinishRow[c] = fmtDateTime(finishDt);
        }

        const idxTotalIn = rows.findIndex(r => norm(r[0]) === "TOTAL IN");
        const insertAt = idxTotalIn >= 0 ? idxTotalIn + 1 : rows.length;
        rows.splice(insertAt, 0, estFinishRow);

        // Precompute autoSum
        const autoSumByCol = {};
        const maxCols = Math.max(...rows.map(r => r.length));
        for (let c = 1; c < maxCols; c++) autoSumByCol[c] = sumAutosForCol(rows, c);

        // Build table
        const table = document.createElement("table");

        rows.forEach((row, rowIndex) => {
          const nonEmptyCount = row.filter(cell => {
            const cc = norm(cell);
            return cc !== "" && cc !== "NA";
          }).length;
          if (nonEmptyCount === 0) return;

          const tr = document.createElement("tr");
          const isHeader = rowIndex === 0;
          const rowLabel = norm(row[0]);
          const isTesterOrHandlerRow = !isHeader && row.some(cell => /tester|handler/i.test((cell || "").toString()));

          row.forEach((cell, colIndex) => {
            let cellContent = (cell ?? "").toString();
            const c = cellContent.trim().toUpperCase();

            if (isHeader && c === "TESTER") {
              cellContent = showLinks
                ? `<a href="https://connect.raspberrypi.com/devices/60a5a481-6e1a-43b3-8fd6-95b26e95aca0" target="_blank">TESTER</a>`
                : "TESTER";
            }

            if (!isHeader) {
              if (c === "CHROMA") cellContent = showLinks ? `<a href="https://connect.raspberrypi.com/devices/5fabcfc7-1bf1-445b-bf3d-b3e285895c7e" target="_blank">CHROMA</a>` : "CHROMA";
              if (c === "NS-3")   cellContent = showLinks ? `<a href="https://connect.raspberrypi.com/devices/462b197a-acdb-4c97-bc15-70ab73addc46" target="_blank">NS-3</a>`   : "NS-3";
              if (c === "NS-4")   cellContent = showLinks ? `<a href="https://connect.raspberrypi.com/devices/66fa4727-e6b5-4a1a-855d-1f266270b950" target="_blank">NS-4</a>`   : "NS-4";
              if (c === "NS-5")   cellContent = showLinks ? `<a href="https://connect.raspberrypi.com/devices/468fc957-7879-440e-b1ea-b7e7dfef37f6" target="_blank">NS-5</a>`   : "NS-5";
            }

            if (showLinks && c === "AP-1")   cellContent = `<a href="vnc://AP-1">AP-1</a>`;
            if (showLinks && c === "AP-2")   cellContent = `<a href="vnc://AP-2">AP-2</a>`;
            if (showLinks && c === "S100_1") cellContent = `<a href="vnc://S100-1">S100_1</a>`;
            if (showLinks && c === "S100_2") cellContent = `<a href="vnc://S100-2">S100_2</a>`;

            // LOADING COUNTS progress
            if (!isHeader && rowLabel === "LOADING COUNTS" && colIndex > 0) {
              const loading = toInt(cell);
              const totalIn = totalInByCol[colIndex];
              if (loading !== null && totalIn && totalIn > 0) {
                let pct = (loading / totalIn) * 100;
                pct = Math.max(0, Math.min(100, pct));
                cellContent = `
                  <div class="lc-wrap">
                    <div class="lc-num">${loading.toLocaleString()}</div>
                    <div class="prog"><div class="bar" style="width:${pct.toFixed(1)}%"></div></div>
                    <div class="lc-pct">${pct.toFixed(1)}%</div>
                  </div>
                `;
              }
            }

            // AUTO1 progress + hover mini chart
            if (!isHeader && (rowLabel === "AUTO1" || rowLabel === "AUTO 1") && colIndex > 0) {
              const auto1 = toInt(cell);
              const total = toInt(totalRow[colIndex]);
              if (auto1 !== null && total !== null && total > 0) {
                const lot = getLotForCol(rows, colIndex);
                const step = getStepForCol(rows, colIndex);
                let pct = (auto1 / total) * 100;
                pct = Math.max(0, Math.min(100, pct));
                cellContent = `
                  <div class="lc-wrap">
                    <div class="lc-num">${yieldHoverHtml(auto1.toLocaleString(), lot, step, "AUTO1")}</div>
                    <div class="prog"><div class="bar" style="width:${pct.toFixed(1)}%"></div></div>
                    <div class="lc-pct">${pct.toFixed(1)}%</div>
                  </div>
                `;
              }
            }

            // AUTO2 progress + hover mini chart
            if (!isHeader && (rowLabel === "AUTO2" || rowLabel === "AUTO 2") && colIndex > 0) {
              const auto2 = toInt(cell);
              const total = toInt(totalRow[colIndex]);
              if (auto2 !== null && total !== null && total > 0) {
                const lot = getLotForCol(rows, colIndex);
                const step = getStepForCol(rows, colIndex);
                let pct = (auto2 / total) * 100;
                pct = Math.max(0, Math.min(100, pct));
                cellContent = `
                  <div class="lc-wrap">
                    <div class="lc-num">${yieldHoverHtml(auto2.toLocaleString(), lot, step, "AUTO2")}</div>
                    <div class="prog"><div class="bar" style="width:${pct.toFixed(1)}%"></div></div>
                    <div class="lc-pct">${pct.toFixed(1)}%</div>
                  </div>
                `;
              }
            }

            // AUTO3 progress (no hover)
            if (!isHeader && (rowLabel === "AUTO3" || rowLabel === "AUTO 3") && colIndex > 0) {
              const auto3 = toInt(cell);
              const total = toInt(totalRow[colIndex]);
              if (auto3 !== null && total !== null && total > 0) {
                let pct = (auto3 / total) * 100;
                pct = Math.max(0, Math.min(100, pct));
                cellContent = `
                  <div class="lc-wrap">
                    <div class="lc-num">${auto3.toLocaleString()}</div>
                    <div class="prog"><div class="bar" style="width:${pct.toFixed(1)}%"></div></div>
                    <div class="lc-pct">${pct.toFixed(1)}%</div>
                  </div>
                `;
              }
            }

            // STATUS row links to handler latest.png
            if (!isHeader && rowLabel === "STATUS" && colIndex > 0) {
              const hname = handlerAtCol(colIndex);
              const ip = HANDLER_IP[hname];
              if (ip) {
                const url = `http://${ip}:8080/latest.png?ts=${Date.now()}`;
                cellContent = `<a class="statusLink" href="${url}" target="_blank" rel="noopener">${cellContent}</a>`;
              }
            }

            const cellEl = document.createElement(isHeader ? "th" : "td");
            cellEl.innerHTML = cellContent;

            // First column styling
            if (colIndex === 0) {
              cellEl.style.backgroundColor = isHeader ? "#2c3e50" : "#dff0d8";
              if (isHeader) { cellEl.style.color = "white"; cellEl.style.fontWeight = "bold"; }
            }

            // Tester/Handler row highlight
            if (isTesterOrHandlerRow && !isHeader) {
              cellEl.style.backgroundColor = "#fef2d0";
              cellEl.style.fontWeight = "bold";
            }

            // STATUS cell coloring
            if (!isHeader && rowLabel === "STATUS" && colIndex > 0) {
              const st = (cell || "").toString().trim().toLowerCase();
              if (st === "running") { cellEl.style.color = "green"; cellEl.style.fontWeight = "bold"; cellEl.style.backgroundColor = "#dff6df"; }
              if (st === "error")   { cellEl.style.color = "red";   cellEl.style.fontWeight = "bold"; cellEl.style.backgroundColor = "#ffd6d6"; }
              if (st === "stopped") { cellEl.style.color = "goldenrod"; cellEl.style.fontWeight = "bold"; cellEl.style.backgroundColor = "#fff3cd"; }
              if (st === "maint")   { cellEl.style.color = "blue";  cellEl.style.fontWeight = "bold"; cellEl.style.backgroundColor = "#d6e6ff"; }
            }

            // Number checks
            if (!isHeader && colIndex > 0) {
              const autoSum = autoSumByCol[colIndex] || 0;

              if (rowLabel === "LOADING COUNTS") {
                const loading = toInt(cell);
                if (loading !== null && loading < autoSum) {
                  cellEl.style.backgroundColor = "#ffd6d6";
                  cellEl.style.fontWeight = "bold";
                  cellEl.style.color = "red";
                }
              }

              if (rowLabel === "TOTAL") {
                const total = toInt(cell);
                if (total !== null && total < autoSum) {
                  cellEl.style.backgroundColor = "#ffd6d6";
                  cellEl.style.fontWeight = "bold";
                  cellEl.style.color = "red";
                }
              }

              if (rowLabel === "TOTAL IN") {
                const totalIn = toInt(cell);
                const loading = toInt(loadingRow[colIndex]);
                if (totalIn !== null && loading !== null && totalIn < loading) {
                  cellEl.style.backgroundColor = "#ffd6d6";
                  cellEl.style.fontWeight = "bold";
                  cellEl.style.color = "red";
                }
              }
            }

            tr.appendChild(cellEl);
          });

          table.appendChild(tr);
        });

        const old = document.querySelector("table");
        if (old) old.remove();
        document.body.appendChild(table);
        requestAnimationFrame(() => equalizeLastColumn(table));

        // Bind yield hover drawing
        bindYieldHoverDelegation(rows);

        // Update prev snapshot
        const newPrev = {};
        for (const r of rows) {
          const label = norm(r[0]);
          if (label) newPrev[label] = r.slice();
        }
        prevRowsByLabel = newPrev;

        dbg("Rendered OK.");
      } catch (e) {
        console.error(e);
        dbg("JS error. Open console.");
      }
    }

    window.addEventListener("load", () => {
      loadCSV();
      setInterval(loadCSV, 30000);
    });
  </script>
</body>
</html>
