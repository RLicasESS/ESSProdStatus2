<!-- MARKER: INDEX_DEV_YIELD_TOGGLE_20260207_0610 -->
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>ESS PRODUCTION STATUS (DEV)</title>
  <style>
    table {
      border-collapse: collapse;
      width: 60%;
      margin: 20px auto;
      font-family: Arial, sans-serif;
    }
    th, td {
      border: 1px solid #aaa;
      padding: 8px 12px;
      text-align: left;
    }
    th {
      background-color: #2c3e50;
      color: white;
      font-weight: bold;
    }

    a { color: #007bff; font-weight: bold; text-decoration: none; }
    a:hover { text-decoration: underline; }

    a.statusLink,
    a.statusLink:visited,
    a.statusLink:hover,
    a.statusLink:active {
      color: inherit !important;
      font-weight: inherit !important;
      text-decoration: underline;
      cursor: pointer;
    }

    #dbg {
      width: 60%;
      margin: 6px auto 0 auto;
      font-family: Arial, sans-serif;
      font-size: 13px;
      color: #555;
      display: none;
    }

    .lc-wrap { display: flex; flex-direction: column; gap: 6px; }
    .lc-num  { font-weight: 600; }
    .prog {
      height: 12px;
      border: 1px solid #bbb;
      border-radius: 8px;
      background: #f2f2f2;
      overflow: hidden;
    }
    .prog > .bar {
      height: 100%;
      width: 0%;
      background: #2e7d32;
    }
    .lc-pct { font-size: 12px; color: #444; }

    /* ===== Yield hover mini-chart ===== */
    .yieldHover {
      position: relative;
      display: inline-block;
      cursor: pointer;
      text-decoration: underline;
    }
    .yieldTip {
      display: none;
      position: absolute;
      z-index: 9999;
      top: 20px;
      left: 0;
      width: 220px;
      padding: 10px;
      border: 1px solid #aaa;
      background: white;
      box-shadow: 0 2px 10px rgba(0,0,0,0.15);
      border-radius: 8px;
    }
    .yieldTipTitle {
      font-size: 12px;
      font-weight: 700;
      color: #222;
      margin-bottom: 6px;
    }
    .yieldTipSub {
      font-size: 11px;
      color: #555;
      margin-bottom: 8px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 210px;
    }
    .yieldCanvas {
      width: 200px;
      height: 70px;
      border: 1px solid #ddd;
      border-radius: 6px;
      display: block;
    }
    .yieldLegend {
      font-size: 11px;
      color: #444;
      margin-top: 6px;
      display: flex;
      justify-content: space-between;
    }

    /* ===== Top bar toggle ===== */
    .topbar {
      width: 60%;
      margin: 0 auto;
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-family: Arial, sans-serif;
    }
    .pill {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      border: 1px solid #bbb;
      border-radius: 999px;
      padding: 6px 10px;
      background: #fafafa;
      font-size: 13px;
      color: #333;
      user-select: none;
    }
    .btn {
      border: 1px solid #999;
      border-radius: 999px;
      padding: 6px 10px;
      background: #fff;
      cursor: pointer;
      font-weight: 700;
      font-size: 12px;
    }
    .btn:hover { background: #f2f2f2; }
    .modeTag {
      font-weight: 800;
      padding: 2px 8px;
      border-radius: 999px;
      border: 1px solid #ccc;
      background: #fff;
      font-size: 12px;
    }
  </style>
</head>

<body>
  <h2 id="pageTitle" style="text-align:center;">ESS PRODUCTION STATUS (DEV)</h2>

  <div class="topbar">
    <div id="modePill" class="pill">
      Yield Data:
      <span id="modeTag" class="modeTag">REAL</span>
      <span id="modeNote" style="font-size:12px;color:#666;"></span>
    </div>
    <button id="toggleBtn" class="btn">USE MOCK</button>
  </div>

  <div id="dbg"></div>

  <script>
    const params = new URLSearchParams(window.location.search);
    const showLinks = params.get("links") === "1";
    const debug = params.get("debug") === "1";

    // Force title always
    document.title = "ESS PRODUCTION STATUS (DEV)";

    const dbgEl = document.getElementById("dbg");
    if (debug) dbgEl.style.display = "block";
    function dbg(msg) { if (debug) dbgEl.textContent = msg; }

    // ====== YOUR CSV ======
    const CSV_URL = "https://raw.githubusercontent.com/RLicasESS/ESSProdStatus2/main/ESSProd.csv";

    // ====== Yield JSON (REAL) ======
    const YIELD_URL_REAL = "https://raw.githubusercontent.com/RLicasESS/ESSProdStatus2/main/yield_live.json";

    // ===== Yield Mode (REAL vs MOCK) =====
    // Priority: query param -> localStorage -> default REAL
    function getYieldMode() {
      const q = params.get("mock");
      if (q === "1") return "MOCK";
      if (q === "0") return "REAL";
      const saved = (localStorage.getItem("yield_mode") || "").toUpperCase();
      if (saved === "MOCK" || saved === "REAL") return saved;
      return "REAL";
    }
    function setYieldMode(mode) {
      localStorage.setItem("yield_mode", mode);
    }

    let yieldMode = getYieldMode();
    const modeTag = document.getElementById("modeTag");
    const modeNote = document.getElementById("modeNote");
    const toggleBtn = document.getElementById("toggleBtn");

    function updateModeUI() {
      modeTag.textContent = yieldMode;
      toggleBtn.textContent = (yieldMode === "REAL") ? "USE MOCK" : "USE REAL";
      modeNote.textContent = (yieldMode === "REAL")
        ? "(from yield_live.json)"
        : "(generated demo points)";
    }
    updateModeUI();

    toggleBtn.addEventListener("click", () => {
      yieldMode = (yieldMode === "REAL") ? "MOCK" : "REAL";
      setYieldMode(yieldMode);
      updateModeUI();
      // reload yield cache so hover updates immediately
      yieldCache = null;
      yieldCacheLoadedAt = 0;
      dbg("Yield mode switched: " + yieldMode);
    });

    // ===== handler -> IP (used by STATUS row link) =====
    const HANDLER_IP = {
      "NS-3": "10.20.10.187",
      "NS-4": "10.20.10.238",
      "NS-5": "10.20.10.98",
      "CHROMA": "10.20.10.38",
    };

    function equalizeLastColumn(table) {
      if (!table) return;
      const headerRow = table.querySelector("tr");
      if (!headerRow) return;
      const heads = Array.from(headerRow.children);
      if (heads.length < 3) return;
      const lastIdx = heads.length - 1;

      const widths = [];
      for (let i = 1; i <= lastIdx - 1; i++) {
        const w = heads[i].getBoundingClientRect().width;
        if (w > 0) widths.push(w);
      }
      if (!widths.length) return;

      const avg = widths.reduce((a, b) => a + b, 0) / widths.length;

      for (const row of Array.from(table.rows)) {
        const cell = row.cells[lastIdx];
        if (cell) {
          cell.style.width = avg.toFixed(1) + "px";
          cell.style.maxWidth = avg.toFixed(1) + "px";
        }
      }
    }

    function norm(s) {
      return (s || "").toString().replace(/\r/g, "").trim().toUpperCase();
    }
    function toInt(x) {
      const v = parseInt((x || "").toString().replace(/,/g, "").trim(), 10);
      return Number.isNaN(v) ? null : v;
    }
    function toInt0(x) {
      const n = parseInt(String(x ?? "").replace(/[^\d-]/g, ""), 10);
      return Number.isFinite(n) ? n : 0;
    }

    function sumAutosForCol(rows, colIndex) {
      const a1 = rows.find(r => norm(r[0]) === "AUTO1") || [];
      const a2 = rows.find(r => norm(r[0]) === "AUTO2") || [];
      const a3 = rows.find(r => norm(r[0]) === "AUTO3") || [];
      return (toInt(a1[colIndex]) || 0) + (toInt(a2[colIndex]) || 0) + (toInt(a3[colIndex]) || 0);
    }

    function parseCSV(text) {
      const lines = text.replace(/\r/g, "").trim().split(/\n/);
      if (!lines.length) return [];
      const first = lines[0];
      const delim = first.includes("\t") ? "\t" : ",";
      return lines.map(line => line.split(delim));
    }

    function parseDateTimeLocal(s) {
      const raw = (s || "").toString().trim();
      if (!raw) return null;
      let x = raw.replace(" ", "T");
      x = x.replace(/\.(\d{3})\d+/, ".$1");
      const d = new Date(x);
      return Number.isNaN(d.getTime()) ? null : d;
    }
    function pad2(n) { return String(n).padStart(2, "0"); }
    function fmtDateTime(d) {
      return `${d.getFullYear()}-${pad2(d.getMonth() + 1)}-${pad2(d.getDate())} ${pad2(d.getHours())}:${pad2(d.getMinutes())}`;
    }

    window.addEventListener("resize", () => {
      const t = document.querySelector("table");
      if (t) requestAnimationFrame(() => equalizeLastColumn(t));
    });

    function findRowByLabel(rows, label) {
      const want = norm(label);
      return (rows || []).find(r => norm(r[0]) === want) || null;
    }

    function getStepForCol(rows, colIndex) {
      const stepRow = findRowByLabel(rows, "TEST STEP");
      if (!stepRow) return "";
      return (stepRow[colIndex] || "").toString().trim();
    }

    function getLotForCol(rows, colIndex) {
      const lotRow = findRowByLabel(rows, "LOT NUMBER");
      if (!lotRow) return "";
      return (lotRow[colIndex] || "").toString().trim();
    }

    // ===== Yield cache loading =====
    let yieldCache = null;
    let yieldCacheLoadedAt = 0;

    function makeMockYieldData(rows) {
      // Build mock data based on current visible lots/steps so it always "matches"
      const header = rows[0] || [];
      const maxCols = Math.max(...rows.map(r => r.length));
      const out = { meta: { updated: new Date().toISOString(), mock: true }, data: {} };

      for (let c = 1; c < maxCols; c++) {
        const lot = getLotForCol(rows, c);
        const step = getStepForCol(rows, c);
        if (!lot || !step || norm(lot) === "NA" || norm(step) === "NA") continue;

        for (const which of ["AUTO1", "AUTO2"]) {
          const key = `${lot}|${step}|${which}`;
          const base = 0.92 - (Math.random() * 0.08);
          const pts = [];
          const now = Date.now();
          for (let i = 12; i >= 0; i--) {
            const y = Math.max(0.80, Math.min(0.99, base + (Math.random() - 0.5) * 0.03));
            pts.push({
              t: new Date(now - i * 5 * 60 * 1000).toISOString(),
              tester: (header[c] || "").toString().trim(),
              good: 1000 + i * 30,
              total: 1100 + i * 30,
              yield: y
            });
          }
          out.data[key] = pts;
        }
      }
      out.meta.active_keys = Object.keys(out.data).length;
      return out;
    }

    async function loadYieldCache(rowsForMock) {
      const ageMs = Date.now() - yieldCacheLoadedAt;
      if (yieldCache && ageMs < 15000) return yieldCache; // small cache

      if (yieldMode === "MOCK") {
        yieldCache = makeMockYieldData(rowsForMock);
        yieldCacheLoadedAt = Date.now();
        return yieldCache;
      }

      // REAL
      const url = YIELD_URL_REAL + (YIELD_URL_REAL.includes("?") ? "&" : "?") + "v=" + Date.now();
      const res = await fetch(url, { cache: "no-store" });
      if (!res.ok) throw new Error("Yield JSON fetch failed: " + res.status);
      const json = await res.json();
      yieldCache = json;
      yieldCacheLoadedAt = Date.now();
      return yieldCache;
    }

    function getYieldSeries(yieldJson, lot, step, which) {
      const key = `${lot}|${step}|${which}`;
      const arr = (yieldJson && yieldJson.data && yieldJson.data[key]) ? yieldJson.data[key] : null;
      return Array.isArray(arr) ? arr : null;
    }

    function drawMiniChart(canvas, series) {
      const ctx = canvas.getContext("2d");
      const w = canvas.width, h = canvas.height;

      // clear
      ctx.clearRect(0, 0, w, h);

      // grid baseline
      ctx.strokeStyle = "#eee";
      ctx.lineWidth = 1;
      for (let i = 1; i <= 3; i++) {
        const y = (h * i) / 4;
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(w, y);
        ctx.stroke();
      }

      if (!series || series.length < 2) {
        ctx.fillStyle = "#666";
        ctx.font = "12px Arial";
        ctx.fillText("no history", 10, 20);
        return;
      }

      // map yields 0..1 -> chart
      const ys = series.map(p => (typeof p.yield === "number" ? p.yield : null)).filter(v => v !== null);
      if (ys.length < 2) return;

      const minY = Math.max(0, Math.min(...ys));
      const maxY = Math.min(1, Math.max(...ys));
      const span = Math.max(0.0001, maxY - minY);

      function xAt(i) { return (i / (series.length - 1)) * (w - 10) + 5; }
      function yAt(v) {
        const t = (v - minY) / span;
        return (h - 8) - t * (h - 16);
      }

      ctx.strokeStyle = "#2e7d32";
      ctx.lineWidth = 2;
      ctx.beginPath();
      series.forEach((p, i) => {
        const v = (typeof p.yield === "number") ? p.yield : minY;
        const x = xAt(i);
        const y = yAt(v);
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      });
      ctx.stroke();

      // last point dot
      const last = series[series.length - 1];
      const lv = (typeof last.yield === "number") ? last.yield : minY;
      ctx.fillStyle = "#1b5e20";
      ctx.beginPath();
      ctx.arc(xAt(series.length - 1), yAt(lv), 3, 0, Math.PI * 2);
      ctx.fill();
    }

    function makeYieldHoverEl(labelText, lot, step, which, rowsForMock) {
      const wrap = document.createElement("span");
      wrap.className = "yieldHover";
      wrap.textContent = labelText;

      const tip = document.createElement("div");
      tip.className = "yieldTip";

      const title = document.createElement("div");
      title.className = "yieldTipTitle";
      title.textContent = `${which} yield (history)`;

      const sub = document.createElement("div");
      sub.className = "yieldTipSub";
      sub.textContent = `${lot} / ${step}`;

      const canvas = document.createElement("canvas");
      canvas.className = "yieldCanvas";
      canvas.width = 200;
      canvas.height = 70;

      const legend = document.createElement("div");
      legend.className = "yieldLegend";
      legend.innerHTML = `<span>old</span><span>new</span>`;

      tip.appendChild(title);
      tip.appendChild(sub);
      tip.appendChild(canvas);
      tip.appendChild(legend);
      wrap.appendChild(tip);

      let loaded = false;

      async function ensureLoaded() {
        if (loaded) return;
        loaded = true;
        try {
          const yj = await loadYieldCache(rowsForMock);
          const series = getYieldSeries(yj, lot, step, which);
          drawMiniChart(canvas, series);
        } catch (e) {
          const ctx = canvas.getContext("2d");
          ctx.clearRect(0,0,canvas.width,canvas.height);
          ctx.fillStyle = "#b00020";
          ctx.font = "12px Arial";
          ctx.fillText("missing lot history", 10, 20);
        }
      }

      wrap.addEventListener("mouseenter", () => {
        tip.style.display = "block";
        ensureLoaded();
      });
      wrap.addEventListener("mouseleave", () => {
        tip.style.display = "none";
      });

      return wrap;
    }

    let prevRowsByLabel = null;

    async function loadCSV() {
      try {
        dbg("Loading CSVâ€¦");

        const resp = await fetch(
          CSV_URL + (CSV_URL.includes("?") ? "&" : "?") + "v=" + Date.now(),
          { cache: "no-store" }
        );

        if (!resp.ok) {
          dbg(`CSV fetch failed: ${resp.status} ${resp.statusText}`);
          return;
        }

        const text = await resp.text();
        const rows = parseCSV(text);
        if (!rows.length) {
          dbg("CSV parsed but rows is empty.");
          return;
        }

        // handler row
        const handlerRow = rows.find(r => norm(r[0]) === "HANDLER") || [];
        function handlerAtCol(colIndex) {
          return (handlerRow[colIndex] || "").toString().trim().toUpperCase();
        }

        // STATUS per column
        const statusRow = rows.find(r => norm(r[0]) === "STATUS") || [];
        const statusByCol = {};
        for (let c = 1; c < statusRow.length; c++) {
          statusByCol[c] = (statusRow[c] || "").toString().trim().toLowerCase();
        }

        // TOTAL IN per column
        const totalInRow = rows.find(r => norm(r[0]) === "TOTAL IN") || [];
        const totalInByCol = {};
        for (let c = 1; c < totalInRow.length; c++) {
          const v = toInt(totalInRow[c]);
          if (v !== null) totalInByCol[c] = v;
        }

        // TOTAL row
        const totalRow = rows.find(r => norm(r[0]) === "TOTAL") || [];

        // Freeze numeric values when STATUS=error
        const freezeLabels = new Set(["TOTAL IN", "LOADING COUNTS", "TOTAL", "AUTO1", "AUTO2", "AUTO3"]);
        if (prevRowsByLabel) {
          for (const r of rows) {
            const label = norm(r[0]);
            if (!freezeLabels.has(label)) continue;
            const prevRow = prevRowsByLabel[label];
            if (!prevRow) continue;

            for (let c = 1; c < r.length; c++) {
              if ((statusByCol[c] || "") === "error") {
                const prevVal = prevRow[c];
                if (prevVal !== undefined && String(prevVal).trim() !== "") {
                  r[c] = prevVal;
                }
              }
            }
          }
        }

        function findLastRow(rows, label) {
          const want = norm(label);
          for (let i = rows.length - 1; i >= 0; i--) {
            if (norm(rows[i]?.[0]) === want) return rows[i];
          }
          return null;
        }

        const startRow   = rows.find(r => norm(r[0]) === "DATE LOT STARTED") || [];
        const lastUpdRow = findLastRow(rows, "LAST UPDATE") || [];
        const loadingRow = rows.find(r => norm(r[0]) === "LOADING COUNTS") || [];

        const estFinishRow = [];
        estFinishRow[0] = "ESTIMATED FINISH";
        const maxColsEF = Math.max(...rows.map(r => r.length));
        for (let c = 1; c < maxColsEF; c++) {
          const startDt = parseDateTimeLocal(startRow[c]);
          const updDt   = parseDateTimeLocal(lastUpdRow[c]);

          const loading = toInt(loadingRow[c]);
          const totalIn = totalInByCol[c];

          if (!startDt || !updDt || loading === null || !totalIn || totalIn <= 0) {
            estFinishRow[c] = "";
            continue;
          }

          const elapsedMs = updDt.getTime() - startDt.getTime();
          const progress = loading / totalIn;

          if (elapsedMs <= 0 || progress <= 0) {
            estFinishRow[c] = "";
            continue;
          }

          const p = Math.min(1, Math.max(0.000001, progress));
          const estTotalMs = elapsedMs / p;
          const finishDt = new Date(startDt.getTime() + estTotalMs);
          estFinishRow[c] = fmtDateTime(finishDt);
        }

        const idxTotalIn = rows.findIndex(r => norm(r[0]) === "TOTAL IN");
        const insertAt = idxTotalIn >= 0 ? idxTotalIn + 1 : rows.length;
        rows.splice(insertAt, 0, estFinishRow);

        // Precompute autoSum
        const autoSumByCol = {};
        const maxCols = Math.max(...rows.map(r => r.length));
        for (let c = 1; c < maxCols; c++) {
          autoSumByCol[c] = sumAutosForCol(rows, c);
        }

        // Build table
        const table = document.createElement("table");

        rows.forEach((row, rowIndex) => {
          const nonEmptyCount = row.filter(cell => {
            const cc = norm(cell);
            return cc !== "" && cc !== "NA";
          }).length;
          if (nonEmptyCount === 0) return;

          const tr = document.createElement("tr");
          const isHeader = rowIndex === 0;
          const rowLabel = norm(row[0]);
          const isTesterOrHandlerRow = !isHeader && row.some(cell => /tester|handler/i.test((cell || "").toString()));

          row.forEach((cell, colIndex) => {
            let cellContent = (cell ?? "").toString();
            const c = cellContent.trim().toUpperCase();

            // links mode: TESTER header links
            if (isHeader && c === "TESTER") {
              cellContent = showLinks
                ? `<a href="https://connect.raspberrypi.com/devices" target="_blank">TESTER</a>`
                : "TESTER";
            }

            // Handler links
            if (!isHeader) {
              if (c === "CHROMA") cellContent = showLinks ? `<a href="https://connect.raspberrypi.com/devices/5fabcfc7-1bf1-445b-bf3d-b3e285895c7e" target="_blank">CHROMA</a>` : "CHROMA";
              if (c === "NS-3")   cellContent = showLinks ? `<a href="https://connect.raspberrypi.com/devices/462b197a-acdb-4c97-bc15-70ab73addc46" target="_blank">NS-3</a>`   : "NS-3";
              if (c === "NS-4")   cellContent = showLinks ? `<a href="https://connect.raspberrypi.com/devices/66fa4727-e6b5-4a1a-855d-1f266270b950" target="_blank">NS-4</a>`   : "NS-4";
              if (c === "NS-5")   cellContent = showLinks ? `<a href="https://connect.raspberrypi.com/devices/468fc957-7879-440e-b1ea-b7e7dfef37f6" target="_blank">NS-5</a>`   : "NS-5";
            }

            // VNC links
            if (showLinks && c === "AP-1")   cellContent = `<a href="vnc://AP-1">AP-1</a>`;
            if (showLinks && c === "AP-2")   cellContent = `<a href="vnc://AP-2">AP-2</a>`;
            if (showLinks && c === "S100_1") cellContent = `<a href="vnc://S100-1">S100_1</a>`;
            if (showLinks && c === "S100_2") cellContent = `<a href="vnc://S100-2">S100_2</a>`;

            // LOADING COUNTS progress
            if (!isHeader && rowLabel === "LOADING COUNTS" && colIndex > 0) {
              const loading = toInt(cell);
              const totalIn = totalInByCol[colIndex];
              if (loading !== null && totalIn && totalIn > 0) {
                let pct = (loading / totalIn) * 100;
                pct = Math.max(0, Math.min(100, pct));
                cellContent = `
                  <div class="lc-wrap">
                    <div class="lc-num">${loading.toLocaleString()}</div>
                    <div class="prog"><div class="bar" style="width:${pct.toFixed(1)}%"></div></div>
                    <div class="lc-pct">${pct.toFixed(1)}%</div>
                  </div>
                `;
              }
            }

            // AUTO1 / AUTO2 progress + yield hover mini-chart on the *number*
            if (!isHeader && (rowLabel === "AUTO1" || rowLabel === "AUTO 1") && colIndex > 0) {
              const auto1 = toInt(cell);
              const total = toInt(totalRow[colIndex]);
              if (auto1 !== null && total !== null && total > 0) {
                const lot = getLotForCol(rows, colIndex);
                const step = getStepForCol(rows, colIndex);

                const pct = Math.max(0, Math.min(100, (auto1 / total) * 100));
                // Wrap the numeric display with yield hover
                const tmp = document.createElement("div");
                tmp.className = "lc-wrap";

                const numLine = document.createElement("div");
                numLine.className = "lc-num";
                const hoverEl = makeYieldHoverEl(auto1.toLocaleString(), lot, step, "AUTO1", rows);
                numLine.appendChild(hoverEl);

                const bar = document.createElement("div");
                bar.className = "prog";
                bar.innerHTML = `<div class="bar" style="width:${pct.toFixed(1)}%"></div>`;

                const pctEl = document.createElement("div");
                pctEl.className = "lc-pct";
                pctEl.textContent = pct.toFixed(1) + "%";

                tmp.appendChild(numLine);
                tmp.appendChild(bar);
                tmp.appendChild(pctEl);

                // convert to HTML
                cellContent = tmp.outerHTML;
              }
            }

            if (!isHeader && (rowLabel === "AUTO2" || rowLabel === "AUTO 2") && colIndex > 0) {
              const auto2 = toInt(cell);
              const total = toInt(totalRow[colIndex]);
              if (auto2 !== null && total !== null && total > 0) {
                const lot = getLotForCol(rows, colIndex);
                const step = getStepForCol(rows, colIndex);

                const pct = Math.max(0, Math.min(100, (auto2 / total) * 100));
                const tmp = document.createElement("div");
                tmp.className = "lc-wrap";

                const numLine = document.createElement("div");
                numLine.className = "lc-num";
                const hoverEl = makeYieldHoverEl(auto2.toLocaleString(), lot, step, "AUTO2", rows);
                numLine.appendChild(hoverEl);

                const bar = document.createElement("div");
                bar.className = "prog";
                bar.innerHTML = `<div class="bar" style="width:${pct.toFixed(1)}%"></div>`;

                const pctEl = document.createElement("div");
                pctEl.className = "lc-pct";
                pctEl.textContent = pct.toFixed(1) + "%";

                tmp.appendChild(numLine);
                tmp.appendChild(bar);
                tmp.appendChild(pctEl);

                cellContent = tmp.outerHTML;
              }
            }

            // AUTO3 progress (unchanged)
            if (!isHeader && (rowLabel === "AUTO3" || rowLabel === "AUTO 3") && colIndex > 0) {
              const auto3 = toInt(cell);
              const total = toInt(totalRow[colIndex]);
              if (auto3 !== null && total !== null && total > 0) {
                let pct = (auto3 / total) * 100;
                pct = Math.max(0, Math.min(100, pct));
                cellContent = `
                  <div class="lc-wrap">
                    <div class="lc-num">${auto3.toLocaleString()}</div>
                    <div class="prog"><div class="bar" style="width:${pct.toFixed(1)}%"></div></div>
                    <div class="lc-pct">${pct.toFixed(1)}%</div>
                  </div>
                `;
              }
            }

            // STATUS row links to handler /latest.png
            if (!isHeader && rowLabel === "STATUS" && colIndex > 0) {
              const hname = handlerAtCol(colIndex);
              const ip = HANDLER_IP[hname];
              if (ip) {
                const url = `http://${ip}:8080/latest.png?ts=${Date.now()}`;
                cellContent = `<a class="statusLink" href="${url}" target="_blank" rel="noopener">${cellContent}</a>`;
              }
            }

            const cellEl = document.createElement(isHeader ? "th" : "td");
            cellEl.innerHTML = cellContent;

            // First column styling
            if (colIndex === 0) {
              cellEl.style.backgroundColor = isHeader ? "#2c3e50" : "#dff0d8";
              if (isHeader) {
                cellEl.style.color = "white";
                cellEl.style.fontWeight = "bold";
              }
            }

            // Tester/Handler row highlight
            if (isTesterOrHandlerRow && !isHeader) {
              cellEl.style.backgroundColor = "#fef2d0";
              cellEl.style.fontWeight = "bold";
            }

            // STATUS cell coloring
            if (!isHeader && rowLabel === "STATUS" && colIndex > 0) {
              const st = (cell || "").toString().trim().toLowerCase();
              if (st === "running") { cellEl.style.color = "green"; cellEl.style.fontWeight = "bold"; cellEl.style.backgroundColor = "#dff6df"; }
              if (st === "error")   { cellEl.style.color = "red";   cellEl.style.fontWeight = "bold"; cellEl.style.backgroundColor = "#ffd6d6"; }
              if (st === "stopped") { cellEl.style.color = "goldenrod"; cellEl.style.fontWeight = "bold"; cellEl.style.backgroundColor = "#fff3cd"; }
              if (st === "maint")   { cellEl.style.color = "blue";  cellEl.style.fontWeight = "bold"; cellEl.style.backgroundColor = "#d6e6ff"; }
            }

            // Number checks
            if (!isHeader && colIndex > 0) {
              const autoSum = autoSumByCol[colIndex] || 0;
              if (rowLabel === "LOADING COUNTS") {
                const loading = toInt(cell);
                if (loading !== null && loading < autoSum) {
                  cellEl.style.backgroundColor = "#ffd6d6";
                  cellEl.style.fontWeight = "bold";
                  cellEl.style.color = "red";
                }
              }
              if (rowLabel === "TOTAL") {
                const total = toInt(cell);
                if (total !== null && total < autoSum) {
                  cellEl.style.backgroundColor = "#ffd6d6";
                  cellEl.style.fontWeight = "bold";
                  cellEl.style.color = "red";
                }
              }
              if (rowLabel === "TOTAL IN") {
                const totalIn = toInt(cell);
                const loading = toInt(loadingRow[colIndex]);
                if (totalIn !== null && loading !== null && totalIn < loading) {
                  cellEl.style.backgroundColor = "#ffd6d6";
                  cellEl.style.fontWeight = "bold";
                  cellEl.style.color = "red";
                }
              }
            }

            tr.appendChild(cellEl);
          });

          table.appendChild(tr);
        });

        const old = document.querySelector("table");
        if (old) old.remove();
        document.body.appendChild(table);
        requestAnimationFrame(() => equalizeLastColumn(table));

        // Update prev snapshot
        const newPrev = {};
        for (const r of rows) {
          const label = norm(r[0]);
          if (label) newPrev[label] = r.slice();
        }
        prevRowsByLabel = newPrev;

        dbg("Rendered OK.");
      } catch (e) {
        console.error(e);
        dbg("JS error. Open console.");
      }
    }

    window.addEventListener("load", () => {
      loadCSV();
      setInterval(loadCSV, 30000);
    });
  </script>
</body>
</html>
